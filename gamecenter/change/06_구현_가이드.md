# 게임 로직 구현 가이드

## 🚀 구현 시작하기

### 1단계: 기본 게임 구조 정의

#### 플레이어 시스템 구현
위치: `/rudpserver/src/game/player.rs`

```rust
// TODO 구현 예시
pub struct Player {
    pub id: PlayerId,
    pub name: String,
    pub position: Option<Position>,
    // 여기에 게임 특성 추가
    pub health: u32,        // 추가
    pub score: u32,         // 추가
    pub team: TeamType,     // 추가
    pub state: PlayerState, // 추가
}
```

#### 룸 시스템 구현
위치: `/rudpserver/src/game/room_user_manager.rs`

구현해야 할 메서드:
- `create_room()` - 새 게임 룸 생성
- `join_room()` - 플레이어 입장 처리
- `leave_room()` - 플레이어 퇴장 처리
- `start_game()` - 게임 시작 로직
- `end_game()` - 게임 종료 처리

### 2단계: 메시지 프로토콜 정의

#### 게임 메시지 추가
위치: `/rudpserver/src/game/messages.rs`

현재 있는 메시지:
- Connect/Disconnect
- Move/MoveUpdate
- Attack/AttackResult
- Ping/Pong (디버깅용)

추가 필요한 메시지:
- GameStart
- GameEnd
- ScoreUpdate
- TeamChange
- CustomAction

### 3단계: 게임 상태 관리자 구현

#### GameStateManager 확장
위치: `/rudpserver/src/game/state_manager.rs`

```rust
impl GameStateManager {
    // 현재: placeholder 메서드들
    // TODO: 다음 메서드들 구현
    
    pub async fn start_game(&self, room_id: u32) -> Result<()> {
        // 게임 시작 로직
    }
    
    pub async fn process_player_action(&self, player_id: PlayerId, action: GameAction) -> Result<()> {
        // 플레이어 액션 처리
    }
    
    pub async fn update_game_state(&self) -> Result<()> {
        // 게임 상태 업데이트 (틱 처리)
    }
}
```

### 4단계: TCP 서버 메시지 핸들러

#### 메시지 핸들러 구현
위치: `/tcpserver/src/handler/message_handler.rs`

현재 처리 메시지:
- Heartbeat (유지)
- Echo (디버깅)

추가 구현:
```rust
match message {
    GameMessage::JoinRoom { room_id } => {
        // 룸 입장 처리
    }
    GameMessage::PlayerAction { action } => {
        // 액션 처리
    }
    // ... 추가 메시지 타입
}
```

### 5단계: gRPC 서비스 로직

#### 비즈니스 로직 추가
위치: `/grpcserver/src/service/`

- `room_service.rs` - 룸 관리 로직
- `user_service.rs` - 사용자 관리 로직

## 📋 구현 체크리스트

### 필수 구현 사항
- [ ] 플레이어 데이터 구조
- [ ] 룸 관리 시스템
- [ ] 기본 게임 메시지
- [ ] 상태 동기화
- [ ] 에러 처리

### 선택적 구현 사항
- [ ] 팀 시스템
- [ ] 점수 시스템
- [ ] 매치메이킹
- [ ] 랭킹 시스템
- [ ] 채팅 시스템

## 🛠️ 유용한 인프라 활용법

### 1. Redis 활용
```rust
// 게임 상태 저장
let redis_service = get_redis_service().await?;
redis_service.set_game_state(room_id, &game_state).await?;
```

### 2. 성능 모니터링
```rust
// 성능 통계 수집
let mut stats = self.game_stats.write().await;
stats.custom_metric += 1;
```

### 3. 이벤트 브로드캐스트
```rust
// 게임 이벤트 전파
self.event_sender.send(GameEvent::Custom {
    event_type: "game_start".to_string(),
    data: serde_json::to_string(&game_data)?,
})?;
```

## ⚠️ 주의사항

### 성능 고려사항
1. **Lock 최소화**: Arc<RwLock> 사용 시 주의
2. **배치 처리**: Redis 작업은 파이프라인 활용
3. **비동기 처리**: CPU 집약적 작업은 별도 스레드

### 보안 고려사항
1. **입력 검증**: 모든 클라이언트 입력 검증
2. **권한 확인**: 액션 수행 전 권한 체크
3. **Rate Limiting**: 과도한 요청 방지

### 확장성 고려사항
1. **상태 분리**: 게임 로직과 네트워크 분리
2. **모듈화**: 기능별 모듈 분리
3. **테스트**: 단위 테스트 작성

## 📚 참고 자료

### 제공된 도구들
- `/shared/tool/high_performance/` - 성능 최적화 도구
- `/shared/security/` - 보안 미들웨어
- `/shared/service/redis/` - Redis 헬퍼

### 디버깅 도구
- 로깅: `tracing` 매크로 활용
- 모니터링: GameStatistics 구조체
- 프로파일링: PerformanceMonitor

## 🎯 추천 구현 순서

1. **기본 플레이어 시스템** (1-2일)
2. **룸 관리** (1-2일)
3. **메시지 프로토콜** (1일)
4. **게임 로직** (3-5일)
5. **테스트 및 최적화** (2-3일)

총 예상 시간: 1-2주 (기본 게임)