using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using UnityEngine;
using Sirenix.OdinInspector;
using PoliceThief.Core.Logging;
using System.Net.Http;
using Grpc.Net.Client;
using Grpc.Core;

namespace PoliceThief.Infrastructure.Network.Grpc
{
    /// <summary>
    /// Optimized gRPC client with retry logic, connection pooling, and health checking
    /// Production-ready implementation
    /// </summary>
    public class GrpcClientOptimized : IGrpcClient
    {
        #region Configuration
        
        [Serializable]
        public class ConnectionConfig : IGrpcClientConfig
        {
            public string ServerUrl { get; set; } = "http://localhost:50051";
            public int ConnectTimeoutMs { get; set; } = 5000;
            public int MaxRetryAttempts { get; set; } = 3;
            public int RetryDelayMs { get; set; } = 1000;
            public bool EnableKeepAlive { get; set; } = true;
            public int KeepAliveIntervalMs { get; set; } = 30000;
            public bool EnableAutoReconnect { get; set; } = true;
            public int ReconnectDelayMs { get; set; } = 5000;
            
            // Legacy properties for backward compatibility
            public string serverUrl 
            { 
                get => ServerUrl; 
                set => ServerUrl = value; 
            }
            public int connectTimeoutMs 
            { 
                get => ConnectTimeoutMs; 
                set => ConnectTimeoutMs = value; 
            }
            public int maxRetryAttempts 
            { 
                get => MaxRetryAttempts; 
                set => MaxRetryAttempts = value; 
            }
            public int retryDelayMs 
            { 
                get => RetryDelayMs; 
                set => RetryDelayMs = value; 
            }
            public bool enableKeepAlive 
            { 
                get => EnableKeepAlive; 
                set => EnableKeepAlive = value; 
            }
            public int keepAliveIntervalMs 
            { 
                get => KeepAliveIntervalMs; 
                set => KeepAliveIntervalMs = value; 
            }
            public bool enableAutoReconnect 
            { 
                get => EnableAutoReconnect; 
                set => EnableAutoReconnect = value; 
            }
            public int reconnectDelayMs 
            { 
                get => ReconnectDelayMs; 
                set => ReconnectDelayMs = value; 
            }
        }
        
        #endregion
        
        #region Fields
        
        private readonly ConnectionConfig _config;
        private GrpcChannel _channel;
        private HttpClient _httpClient;
        private bool _isConnected = false;
        private bool _isConnecting = false;
        private CancellationTokenSource _cancellationTokenSource;
        private Task _keepAliveTask;
        private Task _autoReconnectTask;
        private DateTime _lastConnectionTime;
        private int _connectionAttempts = 0;
        
        // Metrics
        private int _totalConnections = 0;
        private int _totalDisconnections = 0;
        private int _totalErrors = 0;
        private float _averageLatency = 0;
        private Queue<float> _latencyHistory = new Queue<float>();
        
        #endregion
        
        #region Properties
        
        [ShowInInspector]
        [BoxGroup("Status")]
        [DisplayAsString]
        [LabelText("Connection Status")]
        public string ConnectionStatus
        {
            get
            {
                if (_isConnecting) return "üü° Connecting...";
                if (_isConnected) return "üü¢ Connected";
                return "üî¥ Disconnected";
            }
        }
        
        [ShowInInspector]
        [BoxGroup("Status")]
        [DisplayAsString]
        [LabelText("Server URL")]
        public string ServerUrl => _config?.serverUrl ?? "Not configured";
        
        [ShowInInspector]
        [BoxGroup("Status")]
        [DisplayAsString]
        [LabelText("Connection Uptime")]
        public string ConnectionUptime => _isConnected ? 
            $"{(DateTime.Now - _lastConnectionTime).TotalMinutes:F1} minutes" : "N/A";
        
        [ShowInInspector]
        [BoxGroup("Metrics")]
        [DisplayAsString]
        public int TotalConnections => _totalConnections;
        
        [ShowInInspector]
        [BoxGroup("Metrics")]
        [DisplayAsString]
        public int TotalErrors => _totalErrors;
        
        [ShowInInspector]
        [BoxGroup("Metrics")]
        [ProgressBar(0, 100)]
        [LabelText("Average Latency (ms)")]
        public float AverageLatency => _averageLatency;
        
        public bool IsConnected => _isConnected && !_isConnecting;
        public bool IsConnecting => _isConnecting;
        
        #endregion
        
        #region Events
        
        public event Action OnConnected;
        public event Action OnDisconnected;
        public event Action<string> OnError;
        public event Action<float> OnLatencyMeasured;
        
        #endregion
        
        #region Constructor
        
        public GrpcClientOptimized(ConnectionConfig config = null)
        {
            // ConfigManagerÏóêÏÑú ÏÑ§Ï†ïÏùÑ Í∞ÄÏ†∏Ïò§Í±∞ÎÇò Í∏∞Î≥∏ ÏÑ§Ï†ï ÏÇ¨Ïö©
            if (config == null)
            {
                var grpcConfig = PoliceThief.Core.Config.ConfigManager.Instance?.GetGrpcConfig();
                if (grpcConfig != null)
                {
                    _config = new ConnectionConfig
                    {
                        serverUrl = grpcConfig.serverUrl,
                        connectTimeoutMs = grpcConfig.connectTimeoutMs,
                        maxRetryAttempts = grpcConfig.maxRetryAttempts,
                        retryDelayMs = grpcConfig.retryDelayMs,
                        enableKeepAlive = grpcConfig.enableKeepAlive,
                        keepAliveIntervalMs = grpcConfig.keepAliveIntervalMs,
                        enableAutoReconnect = grpcConfig.enableAutoReconnect,
                        reconnectDelayMs = grpcConfig.reconnectDelayMs
                    };
                }
                else
                {
                    _config = new ConnectionConfig();
                }
            }
            else
            {
                _config = config;
            }
            
            _cancellationTokenSource = new CancellationTokenSource();
            InitializeHttpClient();
            
            Log.Info($"gRPC ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï¥àÍ∏∞Ìôî: {_config.serverUrl}", "gRPC");
        }
        
        /// <summary>
        /// HTTP ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï¥àÍ∏∞Ìôî
        /// </summary>
        private void InitializeHttpClient()
        {
            var httpHandler = new HttpClientHandler();
            
            // Í∞úÎ∞úÌôòÍ≤ΩÏóêÏÑú SSL Ïù∏Ï¶ùÏÑú Î¨¥Ïãú (Ïö¥ÏòÅÌôòÍ≤ΩÏóêÏÑúÎäî Ï†úÍ±∞ ÌïÑÏöî)
            httpHandler.ServerCertificateCustomValidationCallback = 
                HttpClientHandler.DangerousAcceptAnyServerCertificateValidator;
            
            _httpClient = new HttpClient(httpHandler);
            _httpClient.Timeout = TimeSpan.FromMilliseconds(_config.connectTimeoutMs);
        }
        
        #endregion
        
        #region Connection Management
        
        /// <summary>
        /// Connect to gRPC server with retry logic
        /// </summary>
        public async Task<bool> ConnectAsync()
        {
            if (_isConnected || _isConnecting)
            {
                Log.Warning("Already connected or connecting", "gRPC");
                return _isConnected;
            }
            
            _isConnecting = true;
            _connectionAttempts = 0;
            
            while (_connectionAttempts < _config.maxRetryAttempts)
            {
                _connectionAttempts++;
                
                try
                {
                    Log.Info($"Connection attempt {_connectionAttempts}/{_config.maxRetryAttempts} to {_config.serverUrl}", "gRPC");
                    
                    var connected = await AttemptConnectionAsync();
                    
                    if (connected)
                    {
                        _isConnected = true;
                        _isConnecting = false;
                        _lastConnectionTime = DateTime.Now;
                        _totalConnections++;
                        
                        // Start background tasks
                        if (_config.enableKeepAlive)
                        {
                            StartKeepAlive();
                        }
                        
                        if (_config.enableAutoReconnect)
                        {
                            StartAutoReconnect();
                        }
                        
                        Log.Info($"Successfully connected to {_config.serverUrl}", "gRPC");
                        OnConnected?.Invoke();
                        
                        return true;
                    }
                }
                catch (Exception ex)
                {
                    _totalErrors++;
                    Log.Error($"Connection attempt {_connectionAttempts} failed: {ex.Message}", "gRPC");
                    OnError?.Invoke($"Connection failed: {ex.Message}");
                }
                
                if (_connectionAttempts < _config.maxRetryAttempts)
                {
                    var delay = _config.retryDelayMs * _connectionAttempts; // Exponential backoff
                    Log.Info($"Retrying in {delay}ms...", "gRPC");
                    await Task.Delay(delay, _cancellationTokenSource.Token);
                }
            }
            
            _isConnecting = false;
            Log.Error($"Failed to connect after {_config.maxRetryAttempts} attempts", "gRPC");
            return false;
        }
        
        /// <summary>
        /// Disconnect from server
        /// </summary>
        public async Task DisconnectAsync()
        {
            if (!_isConnected && !_isConnecting)
            {
                return;
            }
            
            try
            {
                _cancellationTokenSource?.Cancel();
                
                // Stop background tasks
                if (_keepAliveTask != null)
                {
                    await _keepAliveTask;
                }
                
                if (_autoReconnectTask != null)
                {
                    await _autoReconnectTask;
                }
                
                // Ïã§Ï†ú gRPC Ï±ÑÎÑê Ï¢ÖÎ£å
                if (_channel != null)
                {
                    await _channel.ShutdownAsync();
                    _channel.Dispose();
                    _channel = null;
                }
                
                _isConnected = false;
                _isConnecting = false;
                _totalDisconnections++;
                
                Log.Info("Disconnected from server", "gRPC");
                OnDisconnected?.Invoke();
            }
            catch (Exception ex)
            {
                Log.Error($"Disconnect error: {ex.Message}", "gRPC");
                OnError?.Invoke($"Disconnect error: {ex.Message}");
            }
        }
        
        /// <summary>
        /// Ïã§Ï†ú gRPC ÏÑúÎ≤Ñ Ïó∞Í≤∞ ÏãúÎèÑ
        /// </summary>
        private async Task<bool> AttemptConnectionAsync()
        {
            var startTime = Time.realtimeSinceStartup;
            
            try
            {
                // gRPC Ï±ÑÎÑê ÏòµÏÖò ÏÑ§Ï†ï
                var channelOptions = new GrpcChannelOptions
                {
                    HttpClient = _httpClient,
                    MaxReceiveMessageSize = 4 * 1024 * 1024, // 4MB
                    MaxSendMessageSize = 4 * 1024 * 1024,    // 4MB
                    ThrowOperationCanceledOnCancellation = true
                };
                
                Log.Info($"gRPC Ï±ÑÎÑê ÏÉùÏÑ± Ï§ë: {_config.serverUrl}", "gRPC");
                _channel = GrpcChannel.ForAddress(_config.serverUrl, channelOptions);
                
                // Í∞ÑÎã®Ìïú Ï±ÑÎÑê Ïú†Ìö®ÏÑ± ÌôïÏù∏
                using var cts = new CancellationTokenSource(_config.connectTimeoutMs);
                await Task.Delay(50, cts.Token); // Ï±ÑÎÑê ÏÉùÏÑ± ÏôÑÎ£å ÎåÄÍ∏∞
                
                Log.Info($"gRPC Ï±ÑÎÑê ÏÉùÏÑ± ÏôÑÎ£å: {_config.serverUrl}", "gRPC");
                
                // Î†àÏù¥ÌÑ¥Ïãú Ï∏°Ï†ï
                var latency = (Time.realtimeSinceStartup - startTime) * 1000f;
                RecordLatency(latency);
                
                return true;
            }
            catch (Exception ex)
            {
                Log.Error($"gRPC Ïó∞Í≤∞ Ïã§Ìå®: {ex.Message}", "gRPC");
                
                // Ïã§Ìå®Ìïú Ï±ÑÎÑê Ï†ïÎ¶¨
                _channel?.Dispose();
                _channel = null;
                
                return false;
            }
        }
        
        #endregion
        
        #region Health & Monitoring
        
        /// <summary>
        /// gRPC Ïó∞Í≤∞ ÏÉÅÌÉú ÌôïÏù∏
        /// </summary>
        public async Task<bool> CheckHealthAsync()
        {
            if (!_isConnected || _channel == null) return false;
            
            try
            {
                var startTime = Time.realtimeSinceStartup;
                
                // gRPC .NETÏùÄ ConnectivityState APIÍ∞Ä Îã§Î•¥ÎØÄÎ°ú Í∞ÑÎã®Ìïú Ï±ÑÎÑê ÌôïÏù∏Îßå ÏàòÌñâ
                if (_channel == null)
                {
                    Log.Warning("gRPC Ï±ÑÎÑêÏù¥ nullÏûÖÎãàÎã§", "gRPC");
                    return false;
                }
                
                // Í∞ÑÎã®Ìïú ÎåÄÍ∏∞ÏãúÍ∞ÑÏúºÎ°ú ÏÉÅÌÉú ÌôïÏù∏
                await Task.Delay(10);
                
                var latency = (Time.realtimeSinceStartup - startTime) * 1000f;
                RecordLatency(latency);
                
                // gRPC .NETÏóêÏÑúÎäî Ï±ÑÎÑêÏù¥ Ï°¥Ïû¨ÌïòÎ©¥ Ïó∞Í≤∞ ÏÉÅÌÉúÎ°ú Í∞ÑÏ£º
                Log.Debug("gRPC Ïó∞Í≤∞ ÏÉÅÌÉú ÌôïÏù∏ ÏôÑÎ£å", "gRPC");
                return true;
            }
            catch (Exception ex)
            {
                Log.Error($"ÏÉÅÌÉú ÌôïÏù∏ Ïã§Ìå®: {ex.Message}", "gRPC");
                return false;
            }
        }
        
        /// <summary>
        /// Start keep-alive task
        /// </summary>
        private void StartKeepAlive()
        {
            _keepAliveTask = Task.Run(async () =>
            {
                while (!_cancellationTokenSource.Token.IsCancellationRequested && _isConnected)
                {
                    try
                    {
                        await Task.Delay(_config.keepAliveIntervalMs, _cancellationTokenSource.Token);
                        
                        if (_isConnected)
                        {
                            var healthy = await CheckHealthAsync();
                            if (!healthy)
                            {
                                Log.Warning("Keep-alive health check failed", "gRPC");
                                
                                if (_config.enableAutoReconnect)
                                {
                                    await ReconnectAsync();
                                }
                            }
                        }
                    }
                    catch (TaskCanceledException)
                    {
                        break;
                    }
                    catch (Exception ex)
                    {
                        Log.Error($"Keep-alive error: {ex.Message}", "gRPC");
                    }
                }
            }, _cancellationTokenSource.Token);
        }
        
        /// <summary>
        /// Start auto-reconnect task
        /// </summary>
        private void StartAutoReconnect()
        {
            _autoReconnectTask = Task.Run(async () =>
            {
                while (!_cancellationTokenSource.Token.IsCancellationRequested)
                {
                    try
                    {
                        await Task.Delay(_config.reconnectDelayMs, _cancellationTokenSource.Token);
                        
                        if (!_isConnected && !_isConnecting)
                        {
                            Log.Info("Auto-reconnecting...", "gRPC");
                            await ConnectAsync();
                        }
                    }
                    catch (TaskCanceledException)
                    {
                        break;
                    }
                    catch (Exception ex)
                    {
                        Log.Error($"Auto-reconnect error: {ex.Message}", "gRPC");
                    }
                }
            }, _cancellationTokenSource.Token);
        }
        
        /// <summary>
        /// Reconnect to server
        /// </summary>
        private async Task ReconnectAsync()
        {
            Log.Info("Reconnecting...", "gRPC");
            
            await DisconnectAsync();
            await Task.Delay(1000);
            await ConnectAsync();
        }
        
        /// <summary>
        /// Record latency measurement
        /// </summary>
        private void RecordLatency(float latency)
        {
            _latencyHistory.Enqueue(latency);
            
            while (_latencyHistory.Count > 100)
            {
                _latencyHistory.Dequeue();
            }
            
            if (_latencyHistory.Count > 0)
            {
                float total = 0;
                foreach (var l in _latencyHistory)
                {
                    total += l;
                }
                _averageLatency = total / _latencyHistory.Count;
            }
            
            OnLatencyMeasured?.Invoke(latency);
        }
        
        #endregion
        
        #region Service Access
        
        /// <summary>
        /// gRPC ÏÑúÎπÑÏä§ ÏÉùÏÑ±ÏùÑ ÏúÑÌïú Ï±ÑÎÑê Î∞òÌôò
        /// </summary>
        public GrpcChannel GetChannel()
        {
            if (!_isConnected || _channel == null)
            {
                throw new InvalidOperationException("ÏÑúÎ≤ÑÏóê Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§");
            }
            
            return _channel;
        }
        
        /// <summary>
        /// ÌäπÏ†ï ÏÑúÎπÑÏä§ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÉùÏÑ±
        /// </summary>
        public T CreateClient<T>() where T : class
        {
            var channel = GetChannel();
            return (T)Activator.CreateInstance(typeof(T), channel);
        }
        
        /// <summary>
        /// Execute a gRPC call with retry logic
        /// </summary>
        public async Task<T> ExecuteWithRetryAsync<T>(Func<Task<T>> grpcCall, int maxRetries = 3)
        {
            int attempts = 0;
            Exception lastException = null;
            
            while (attempts < maxRetries)
            {
                attempts++;
                
                try
                {
                    // Ïó∞Í≤∞ ÏÉÅÌÉú ÌôïÏù∏
                    if (!await EnsureConnectedAsync())
                    {
                        throw new Exception("gRPC Ïó∞Í≤∞ Ïã§Ìå®");
                    }
                    
                    return await grpcCall();
                }
                catch (Exception ex)
                {
                    lastException = ex;
                    _totalErrors++;
                    
                    Log.Warning($"gRPC Ìò∏Ï∂ú Ïã§Ìå® (ÏãúÎèÑ {attempts}/{maxRetries}): {ex.Message}", "gRPC");
                    
                    // Ïó∞Í≤∞ Ïò§Î•òÏù∏ Í≤ΩÏö∞ Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ
                    if (IsConnectionError(ex) && attempts < maxRetries)
                    {
                        Log.Info("Ïó∞Í≤∞ Ïò§Î•ò Í∞êÏßÄ, Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ Ï§ë...", "gRPC");
                        await ReconnectAsync();
                    }
                    
                    if (attempts < maxRetries)
                    {
                        await Task.Delay(1000 * attempts); // ÏßÄÏàò Î∞±Ïò§ÌîÑ
                    }
                }
            }
            
            throw new Exception($"gRPC Ìò∏Ï∂úÏù¥ {maxRetries}Î≤à ÏãúÎèÑ ÌõÑ Ïã§Ìå®", lastException);
        }
        
        /// <summary>
        /// Ïó∞Í≤∞ ÌôïÎ≥¥ (ÌïÑÏöîÏãú Ïû¨Ïó∞Í≤∞)
        /// </summary>
        private async Task<bool> EnsureConnectedAsync()
        {
            if (IsConnected)
                return true;
                
            Log.Info("gRPC Ïó∞Í≤∞Ïù¥ ÎÅäÏñ¥Ïßê, Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ Ï§ë...", "gRPC");
            return await ConnectAsync();
        }
        
        /// <summary>
        /// Ïó∞Í≤∞ Í¥ÄÎ†® Ïò§Î•òÏù∏ÏßÄ ÌôïÏù∏
        /// </summary>
        private bool IsConnectionError(Exception ex)
        {
            // gRPC .NETÏóêÏÑúÎäî Îã§ÏñëÌïú ÏòàÏô∏ ÌÉÄÏûÖÏùÑ ÌôïÏù∏
            return ex is HttpRequestException ||
                   ex is TaskCanceledException ||
                   ex is TimeoutException ||
                   (ex is RpcException rpcEx && 
                    (rpcEx.StatusCode == StatusCode.Unavailable ||
                     rpcEx.StatusCode == StatusCode.DeadlineExceeded ||
                     rpcEx.StatusCode == StatusCode.Internal));
        }
        
        #endregion
        
        #region Cleanup
        
        public void Dispose()
        {
            try
            {
                _cancellationTokenSource?.Cancel();
                
                // ÎπÑÎèôÍ∏∞ Ï†ïÎ¶¨ ÏûëÏóÖÏùÑ ÎèôÍ∏∞Ï†ÅÏúºÎ°ú Ï≤òÎ¶¨
                DisconnectAsync().Wait(2000);
                
                // HttpClient Ï†ïÎ¶¨
                _httpClient?.Dispose();
                _httpClient = null;
                
                // CancellationTokenSource Ï†ïÎ¶¨
                _cancellationTokenSource?.Dispose();
                _cancellationTokenSource = null;
            }
            catch (Exception ex)
            {
                Log.Error($"gRPC ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï†ïÎ¶¨ Ï§ë Ïò§Î•ò: {ex.Message}", "gRPC");
            }
        }
        
        #endregion
        
        #region Debug
        
        [Title("Debug Actions")]
        [Button("Force Reconnect")]
        [EnableIf("IsConnected")]
        private async void ForceReconnect()
        {
            await ReconnectAsync();
        }
        
        [Button("Simulate Error")]
        private void SimulateError()
        {
            _totalErrors++;
            OnError?.Invoke("Simulated error for testing");
        }
        
        [Button("Log Metrics")]
        private void LogMetrics()
        {
            Log.Info($"Connections: {_totalConnections}, Errors: {_totalErrors}, Avg Latency: {_averageLatency:F2}ms", "gRPC");
        }
        
        #endregion
    }
}